<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Advanced</title>
    <style>
        /* CSS Custom Properties for easy theming */
        :root {
            --background-color: #ffffff;
            --container-bg-color: #ffffff;
            --grid-border-color: #333;
            --cell-border-color: #ccc;
            --cell-bg-color: #fff;
            --cell-initial-bg-color: #e9e9e9;
            --cell-selected-bg-color: #afeeee;
            --font-color-dark: #333;
            --font-color-light: #fff;
            --font-color-error: #dc3545;
            --font-color-note: #008b8b;
            --font-color-success: #28a745;
            --button-bg-color: #000;
            --button-border-color: #000;
            --win-color-gold: #FFD700;
            --box-shadow-light: 0 4px 8px rgba(0,0,0,0.1);
            --pause-overlay-bg: rgba(255, 255, 255, 0.85);
        }

        body.dark-mode {
            --background-color: #121212;
            --container-bg-color: #121212;
            --grid-border-color: #e0e0e0;
            --cell-border-color: #444;
            --cell-bg-color: #2a2a2a;
            --cell-initial-bg-color: #3c3c3c;
            --cell-selected-bg-color: #005f5f;
            --font-color-dark: #f0f0f0;
            --font-color-light: #121212;
            --font-color-error: #ff7b7b;
            --font-color-note: #48d1cc;
            --font-color-success: #76c7c0;
            --button-bg-color: #f0f0f0;
            --button-border-color: #f0f0f0;
            --pause-overlay-bg: rgba(0, 0, 0, 0.7);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column; 
            align-items: center;
            min-height: 100vh;
            background-color: var(--background-color);
            color: var(--font-color-dark);
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden; 
            margin: 0;
            transition: background-color 0.3s, color 0.3s;
        }

        .sudoku-container {
            display: flex;
            flex-direction: column;
            align-items: center; 
            width: 100%;
            max-width: 550px; /* Begrenzt die Breite auf gro√üen Bildschirmen */
        }

        h1 {
            color: var(--font-color-dark);
            margin-bottom: 20px;
            text-align: center; 
            transition: color 0.5s, transform 0.5s, text-transform 0.5s;
        }
        
        @keyframes headline-pulse { 
            0% { transform: scale(1); } 
            50% { transform: scale(1.1); }
            100% { transform: scale(1); } 
        }
        h1.headline-win {
            text-transform: uppercase;
            color: var(--win-color-gold);
            animation: headline-pulse 1.5s infinite ease-in-out;
        }
        
        .grid-wrapper {
            position: relative;
        }

        /* Grid Styling */
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, minmax(30px, 1fr)); 
            grid-template-rows: repeat(9, minmax(30px, 1fr));    
            width: 90vw; 
            max-width: 500px; 
            aspect-ratio: 1 / 1; 
            border: 3px solid var(--grid-border-color);
            border-radius: 0;
            box-shadow: var(--box-shadow-light);
            margin-bottom: 20px;
            position: relative; 
            touch-action: none;
            border-collapse: collapse; 
            transition: border-color 0.3s, box-shadow 0.3s, border-width 0.3s;
        }
        
        @keyframes rainbow-border-pulse { 
             0% { border-color: #FFB6C1; } 16% { border-color: #FFDAB9; } 33% { border-color: #FFFFE0; }
             50% { border-color: #98FB98; } 66% { border-color: #ADD8E6; } 83% { border-color: #E6E6FA; }
             100% { border-color: #FFB6C1; }
        }
        .sudoku-grid.grid-win {
             border-width: 5px; 
             animation: rainbow-border-pulse 4s infinite linear;
        }

        /* Cell Styling */
        .sudoku-cell {
            display: grid; 
            place-items: center; 
            font-size: clamp(1.2rem, 4vw, 1.8rem); 
            background-color: var(--cell-bg-color);
            border: 1px solid var(--cell-border-color); 
            cursor: pointer;
            transition: background-color 0.2s ease; 
            user-select: none; 
            position: relative; 
            color: var(--font-color-dark);
            margin: -1px 0 0 -1px; 
            overflow: hidden; 
        }
        .sudoku-cell:focus { outline: none; }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid var(--grid-border-color); }
        .sudoku-cell:nth-child(3n) { border-right: 2px solid var(--grid-border-color); }
        .sudoku-cell:nth-child(9n) { border-right: none; }
        .sudoku-cell:nth-child(n+73) { border-bottom: none; }
        
        .sudoku-cell.initial {
            font-weight: bold;
            background-color: var(--cell-initial-bg-color); 
            cursor: not-allowed;
            color: var(--font-color-dark); 
        }
        .sudoku-cell.initial .notes-grid { display: none; }
        .sudoku-cell.selected { background-color: var(--cell-selected-bg-color); }

        .answer-number {
             font-weight: bold;
             grid-area: 1 / 1 / 1 / 1;
             pointer-events: none; 
        }
        .answer-number.error { color: var(--font-color-error) !important; }
        .sudoku-cell.initial .answer-number.error { color: var(--font-color-dark) !important; }

        .notes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%; height: 100%;
            grid-area: 1 / 1 / 1 / 1;
            pointer-events: none; 
        }

        .note-number {
            font-size: clamp(0.6rem, 1.8vw, 0.85rem); 
            color: var(--font-color-note);
            line-height: 1; text-align: center;
            opacity: 0; 
            transition: opacity 0.1s;
        }
        .note-number.visible {
             opacity: 1;
        }
        .note-number[data-note="1"] { grid-area: 1 / 1; } .note-number[data-note="2"] { grid-area: 1 / 2; } .note-number[data-note="3"] { grid-area: 1 / 3; }
        .note-number[data-note="4"] { grid-area: 2 / 1; } .note-number[data-note="5"] { grid-area: 2 / 2; } .note-number[data-note="6"] { grid-area: 2 / 3; }
        .note-number[data-note="7"] { grid-area: 3 / 1; } .note-number[data-note="8"] { grid-area: 3 / 2; } .note-number[data-note="9"] { grid-area: 3 / 3; }

        /* Controls Area */
        .status-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            width: 90%;
            max-width: 500px;
            margin-bottom: 15px;
            font-size: 1rem;
            color: var(--font-color-dark);
            gap: 10px;
        }
        #difficulty-select label { margin-right: 5px; }

        .timer-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #timer { 
            font-weight: bold;
            font-size: 1rem;
            color: var(--font-color-dark);
        }
        #pause-btn {
            background: none;
            border: 1px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            padding: 5px;
            width: 32px;
            height: 32px;
            color: var(--font-color-dark);
            transition: background-color 0.2s, border-color 0.2s;
        }
        #pause-btn:hover { background-color: #e9e9e9; border-color: #ccc; }
        #pause-btn:disabled { cursor: not-allowed; opacity: 0.5; }

        .controls {
            display: flex;
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 10px;
            margin-bottom: 15px; 
        }
        .controls button, .controls select {
            padding: 10px 15px; font-size: 1rem;
            border: 1px solid var(--button-border-color); 
            border-radius: 5px;
            background-color: var(--button-bg-color); 
            color: var(--font-color-light); 
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease; 
        }
        .controls button:disabled { background-color: #aaa; border-color: #999; cursor: not-allowed; opacity: 0.7; }
        @media (hover: hover) { .controls button:not(:disabled):hover { background-color: var(--font-color-dark); color: var(--button-bg-color); } }
        #settings-btn.active { background-color: var(--font-color-dark); color: var(--button-bg-color); }
        @media (hover: hover) { #settings-btn.active:hover { background-color: #eee; } }

        /* Radial Menu */
        #radial-menu { position: fixed; width: 180px; height: 180px; border-radius: 50%; background-color: rgba(200, 200, 200, 0.85); box-shadow: 0 0 15px rgba(0,0,0,0.3); display: none; justify-content: center; align-items: center; z-index: 1000; pointer-events: none; transform: translate(-50%, -50%); user-select: none; touch-action: none; }
        #radial-menu.visible { display: flex; pointer-events: auto; }
        .radial-item { position: absolute; width: 40px; height: 40px; background-color: var(--button-bg-color); border: 1px solid #555; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: all 0.15s ease-out; color: var(--font-color-light); pointer-events: auto; user-select: none; touch-action: none; transform: scale(0.95); }
        @media (hover: hover) { .radial-item:hover { background-color: var(--font-color-dark); color: var(--button-bg-color); border-color: var(--button-bg-color); transform: scale(1.15); z-index: 1; } }
        .radial-item.longpress-active { box-shadow: 0 0 8px 3px #00cccc; transform: scale(1.4); z-index: 2; }

        /* Overlays & Modals */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .overlay.visible { display: flex; }
        .modal {
            background-color: var(--container-bg-color);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 500px;
            text-align: center;
        }
        .modal h2 { margin-top: 0; color: var(--font-color-dark); }
        .modal p { margin-bottom: 20px; }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px;}
        .modal button {
             padding: 10px 20px;
             border-radius: 5px;
             cursor: pointer;
             font-size: 1rem;
             border: 1px solid var(--button-border-color);
             background-color: var(--button-bg-color);
             color: var(--font-color-light);
             transition: background-color 0.2s, color 0.2s;
        }
        .modal button.btn-secondary { background-color: #6c757d; border-color: #6c757d; }
        @media (hover: hover) {
            .modal button:hover { background-color: var(--font-color-dark); color: var(--button-bg-color); }
            .modal button.btn-secondary:hover { background-color: #5a6268; border-color: #545b62; color: var(--font-color-light); }
        }

        /* Best Times & Load Game Modals */
        #best-times-modal h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            text-transform: capitalize;
            border-bottom: 1px solid var(--cell-border-color);
            padding-bottom: 5px;
        }
        #best-times-modal ol { list-style-position: inside; padding-left: 0; }
        #best-times-modal li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        #best-times-modal .btn-play-again {
            padding: 4px 10px;
            font-size: 0.9rem;
            border: 1px solid #888;
            background-color: #f0f0f0;
            color: #333;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 15px;
        }
         @media (hover: hover) {
            #best-times-modal .btn-play-again:hover {
                background-color: #e0e0e0;
                border-color: #555;
            }
        }
        #best-times-modal .no-times { color: #888; }
        #final-time { font-weight: bold; font-size: 1.2rem; color: var(--font-color-success); }
        
        #saved-games-list {
            list-style: none;
            padding: 0;
            max-height: 60vh;
            overflow-y: auto;
            text-align: left;
        }
        .saved-game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--cell-border-color);
        }
         .saved-game-item:last-child {
            border-bottom: none;
        }
        .saved-game-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.9rem;
        }
        .saved-game-info span { text-transform: capitalize; }
        .saved-game-actions button {
            padding: 5px 10px;
            font-size: 0.9rem;
            margin-left: 8px;
        }
         .btn-delete-save {
            background-color: var(--font-color-error);
            border-color: var(--font-color-error);
        }

        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--pause-overlay-bg);
            border-radius: 0; 
            display: none; justify-content: center; align-items: center;
            font-size: 2rem; font-weight: bold; color: var(--font-color-dark);
            z-index: 10; pointer-events: none; text-transform: uppercase;
        }
        .grid-wrapper.paused #pause-overlay { display: flex; pointer-events: auto; }

        #radial-menu-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 999; display: none; background-color: transparent; 
        }

        /* Message Area & Confetti */
        .message-area { min-height: 20px; font-weight: bold; color: var(--font-color-dark); margin-top: 10px; transition: opacity 0.5s ease-out; opacity: 1; width: 90%; max-width: 500px; text-align: center; }
        .message-area.hidden { opacity: 0; }
        .message-area.success { color: var(--font-color-success); }
        .message-area.failure { color: var(--font-color-error); }
        #confetti-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3000; }
        .confetti-piece { position: absolute; width: 8px; height: 16px; opacity: 0; --drift: 0px; animation: confetti-fall 4s linear; }
        @keyframes confetti-fall { 0% { top: -20px; opacity: 1; transform: translateX(0) rotate(0deg); } 100% { top: 110vh; opacity: 1; transform: translateX(var(--drift)) rotate(720deg); } }
    </style>
</head>
<body>

    <div class="sudoku-container">
        <h1 id="main-headline">Sudoku</h1> 

        <div class="status-bar">
            <div id="difficulty-select">
                <label for="difficulty">Schwierigkeitsgrad:</label>
                <select id="difficulty">
                    <option value="easy">Leicht</option>
                    <option value="medium" selected>Mittel</option>
                    <option value="hard">Schwer</option>
                    <option value="expert">Experte</option>
                </select>
            </div>
            <div class="timer-container">
                <span id="timer">00:00</span>
                <button id="pause-btn" title="Spiel pausieren/fortsetzen">&#10074;&#10074;</button>
            </div>
        </div>

        <div class="grid-wrapper">
            <div id="sudoku-grid" class="sudoku-grid"></div>
            <div id="pause-overlay"><span>Pausiert</span></div>
        </div>

        <div class="controls">
            <button id="new-game-btn" title="Neues Zufalls-Puzzle laden">Neues Spiel</button>
            <button id="save-game-btn" title="Aktuelles Spiel speichern">Speichern</button>
            <button id="load-game-btn" title="Gespeichertes Spiel laden">Laden</button>
            <button id="best-times-btn" title="Bestzeiten anzeigen">Bestzeiten</button>
            <button id="reset-btn" title="Aktuelles Puzzle zur√ºcksetzen">Reset</button>
            <button id="undo-btn" title="Letzten Zug r√ºckg√§ngig machen" disabled>&#8617;</button> 
            <button id="validate-btn" title="Aktuelle L√∂sung pr√ºfen">Pr√ºfen</button>
            <button id="settings-btn" title="Sofortige Validierung umschalten">‚öôÔ∏è</button>
            <button id="theme-toggle-btn" title="Modus wechseln">üåô</button> 
        </div>

        <div id="message-area" class="message-area"></div>
    </div>

    <div id="radial-menu"></div>
    <div id="radial-menu-overlay"></div>
    <div id="confetti-container"></div>
    
    <!-- Modals -->
    <div id="save-time-modal" class="overlay">
        <div class="modal">
            <h2>Gl√ºckwunsch!</h2>
            <p>Du hast das Sudoku in <span id="final-time"></span> gel√∂st.</p>
            <p>M√∂chtest du diese Zeit speichern?</p>
            <div class="modal-buttons">
                <button id="save-time-no" class="btn-secondary">Nein</button>
                <button id="save-time-yes">Ja, speichern</button>
            </div>
        </div>
    </div>

    <div id="best-times-modal" class="overlay">
        <div class="modal">
            <h2>Bestzeiten</h2>
            <div id="best-times-content"></div>
            <div class="modal-buttons">
                 <button id="close-best-times">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <div id="load-game-modal" class="overlay">
        <div class="modal">
            <h2>Spielst√§nde laden</h2>
            <ul id="saved-games-list"></ul>
            <div class="modal-buttons">
                 <button id="close-load-game">Schlie√üen</button>
            </div>
        </div>
    </div>


    <script id="sudoku-worker" type="javascript/worker">
        const GRID_SIZE = 9;
        const SUBGRID_SIZE = 3;
        const NUM_CELLS = GRID_SIZE * GRID_SIZE;

        class SudokuGenerator {
            constructor() {
                this.board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                this.counter = 0;
            }

            generate(clues) {
                this.board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                this.fillBoard(this.board);
                this.removeNumbers(clues);
                return this.board;
            }
            
            fillBoard(board) {
                let row = -1, col = -1;
                let isEmpty = true;
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (board[i][j] === 0) {
                            row = i; col = j; isEmpty = false; break;
                        }
                    }
                    if (!isEmpty) break;
                }
                if (isEmpty) return true;

                const numbers = this.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                for (let num of numbers) {
                    if (this.isSafe(board, row, col, num)) {
                        board[row][col] = num;
                        if (this.fillBoard(board)) return true;
                        board[row][col] = 0;
                    }
                }
                return false;
            }
            
            removeNumbers(clues) {
                let attempts = (NUM_CELLS - clues);
                while (attempts > 0) {
                    let row = Math.floor(Math.random() * GRID_SIZE);
                    let col = Math.floor(Math.random() * GRID_SIZE);
                    if (this.board[row][col] !== 0) {
                        const backup = this.board[row][col];
                        this.board[row][col] = 0;
                        
                        const boardCopy = this.board.map(r => [...r]);
                        this.counter = 0;
                        this.solveForUnique(boardCopy);
                        
                        if (this.counter !== 1) {
                            this.board[row][col] = backup;
                        } else {
                            attempts--;
                        }
                    }
                }
            }

            solveForUnique(board) {
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (board[i][j] === 0) {
                            for (let num = 1; num <= GRID_SIZE; num++) {
                                 if (this.counter > 1) break;
                                if (this.isSafe(board, i, j, num)) {
                                    board[i][j] = num;
                                    this.solveForUnique(board);
                                    board[i][j] = 0; // backtrack
                                }
                            }
                            return;
                        }
                    }
                }
                this.counter++;
            }

            isSafe(board, row, col, num) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[row][x] === num || board[x][col] === num) return false;
                }
                const startRow = row - row % SUBGRID_SIZE, startCol = col - col % SUBGRID_SIZE;
                for (let i = 0; i < SUBGRID_SIZE; i++) {
                    for (let j = 0; j < SUBGRID_SIZE; j++) {
                        if (board[i + startRow][j + startCol] === num) return false;
                    }
                }
                return true;
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        self.onmessage = function(e) {
            const { clues } = e.data;
            const generator = new SudokuGenerator();
            const newPuzzle = generator.generate(clues);
            self.postMessage(newPuzzle);
        };
    </script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CONSTANTS ---
        const GRID_SIZE = 9;
        const NUM_CELLS = GRID_SIZE * GRID_SIZE;
        const LONG_PRESS_DURATION = 400;
        const RADIAL_MENU_DIAMETER = 180;
        const REOPEN_DELAY = 100;
        const MAX_BEST_TIMES = 5;

        const DIFFICULTY_LEVELS = { // For generator
            easy: 35,
            medium: 30,
            hard: 25,
        };
        
        const PUZZLES = {
             expert: [
    // Puzzle 1 (21 clues)
    [
      [0,5,0,0,0,2,0,9,0],
      [6,0,0,0,0,0,0,0,0],
      [0,0,8,0,0,0,1,0,6],
      [0,0,7,1,0,0,0,0,2],
      [0,0,0,0,2,5,0,0,0],
      [0,9,0,0,3,0,0,0,0],
      [0,0,0,8,0,0,7,0,1],
      [0,4,0,0,5,0,0,3,0],
      [0,0,0,0,0,0,6,0,0]
    ],
    // Puzzle 2 (21 clues)
    [
      [0,2,0,0,0,6,0,0,0],
      [9,0,0,0,0,0,0,0,0],
      [0,0,8,0,7,0,0,0,4],
      [0,0,0,3,1,0,0,0,8],
      [0,0,3,8,0,0,0,0,0],
      [0,0,0,0,0,5,0,2,0],
      [0,5,0,0,0,0,9,6,0],
      [0,0,7,0,0,0,0,0,1],
      [0,9,0,0,0,3,0,5,0]
    ],
    // Puzzle 3 (21 clues)
    [
      [6,0,0,2,0,0,0,0,4],
      [0,0,3,0,5,0,0,0,0],
      [0,7,0,0,0,0,0,0,0],
      [0,0,0,8,0,1,0,0,6],
      [1,0,0,0,0,6,0,0,0],
      [0,0,0,0,9,0,0,3,0],
      [0,0,9,0,0,0,7,5,0],
      [2,0,0,0,0,0,0,0,8],
      [0,0,7,0,1,0,0,9,0]
    ],
    // Puzzle 4 (21 clues)
    [
      [7,0,0,8,0,0,0,9,0],
      [0,0,5,0,0,0,0,0,0],
      [0,3,0,0,0,0,4,0,5],
      [0,2,0,0,4,0,0,0,8],
      [0,0,0,7,0,8,0,0,0],
      [9,0,0,0,0,6,0,0,0],
      [1,0,0,0,0,7,0,6,0],
      [0,0,0,0,0,0,5,0,0],
      [0,0,0,0,3,0,2,0,4]
    ],
    // Puzzle 5 (21 clues)
    [
      [0,4,0,0,0,8,0,0,0],
      [2,0,0,0,0,0,0,0,0],
      [0,0,6,0,5,0,9,0,0],
      [0,0,1,6,0,0,0,0,0],
      [0,0,0,0,0,3,0,0,4],
      [0,0,0,1,7,0,6,0,0],
      [0,0,5,0,0,0,7,0,0],
      [0,2,0,0,0,1,0,0,3],
      [0,3,0,0,0,0,0,2,8]
    ],
    // Puzzle 6 (21 clues)
    [
      [1,0,0,0,0,0,0,0,0],
      [0,0,6,0,0,3,5,0,0],
      [0,8,0,4,0,0,0,0,0],
      [0,0,0,2,0,0,0,0,8],
      [0,0,0,0,9,7,6,0,0],
      [0,0,9,0,6,0,0,0,0],
      [0,0,3,0,0,0,7,0,0],
      [0,1,0,9,0,0,0,0,2],
      [0,2,0,0,0,0,0,1,4]
    ],
    // Puzzle 7 (21 clues)
    [
      [7,0,0,0,0,0,0,4,1],
      [0,0,6,8,0,0,3,0,0],
      [0,4,0,0,0,0,0,0,0],
      [9,0,0,0,1,0,0,8,0],
      [0,0,0,6,0,8,0,0,0],
      [0,0,3,0,0,2,0,0,0],
      [0,0,5,0,0,6,2,0,0],
      [0,0,0,0,0,0,0,0,4],
      [0,0,0,0,7,0,0,1,9]
    ],
    // Puzzle 8 (21 clues)
    [
      [0,0,8,0,3,0,0,0,0],
      [0,6,0,0,0,0,0,0,0],
      [2,0,0,7,0,0,9,0,0],
      [0,0,0,0,1,0,0,0,8],
      [0,0,0,5,0,4,2,0,0],
      [4,0,0,0,0,2,0,0,0],
      [0,0,6,0,4,0,0,0,1],
      [0,0,1,0,0,0,0,6,3],
      [7,0,0,0,0,0,5,0,0]
    ],
    // Puzzle 9 (21 clues)
    [
      [0,0,2,9,0,0,0,0,8],
      [0,6,0,0,1,0,0,0,0],
      [7,0,0,0,0,0,0,0,0],
      [0,0,0,4,0,5,0,0,2],
      [0,0,5,0,0,2,0,0,0],
      [0,0,0,0,3,0,0,6,0],
      [0,7,0,0,5,0,0,3,0],
      [0,3,0,0,0,0,7,1,0],
      [0,0,9,0,0,0,0,0,4]
    ],
    // Puzzle 10 (21 clues)
    [
      [8,0,0,0,0,0,1,2,0],
      [0,0,6,0,4,0,0,0,9],
      [0,1,0,0,0,0,0,0,0],
      [0,0,0,4,6,0,0,0,0],
      [0,0,9,3,0,0,0,0,0],
      [5,0,0,0,0,2,4,0,0],
      [0,0,0,0,0,0,0,1,0],
      [0,0,0,0,0,8,2,5,0],
      [0,0,7,6,0,0,0,0,3]
    ],
    // Puzzle 11 (21 clues)
    [
      [0,0,1,0,0,4,0,0,0],
      [0,9,0,0,0,0,0,0,0],
      [6,0,0,0,8,0,0,0,2],
      [0,0,0,0,0,7,0,1,0],
      [0,0,0,3,5,0,0,0,6],
      [3,0,0,6,0,0,0,0,0],
      [8,0,0,0,0,0,0,0,5],
      [0,0,9,0,0,3,0,7,0],
      [0,0,7,0,0,0,9,4,0]
    ],
    // Puzzle 12 (21 clues)
    [
      [0,0,7,0,0,0,0,0,0],
      [0,5,0,0,3,0,4,0,0],
      [6,0,0,0,0,8,0,0,0],
      [0,2,0,5,0,0,0,0,0],
      [0,0,0,0,0,9,0,0,6],
      [0,0,0,2,1,0,5,0,0],
      [7,0,0,0,0,2,0,0,9],
      [9,0,0,0,0,0,0,7,8],
      [0,3,0,0,0,0,1,0,0]
    ],
    // Puzzle 13 (21 clues)
    [
      [1,0,0,0,0,0,0,0,0],
      [0,0,3,0,0,0,0,1,5],
      [0,8,0,2,0,0,7,0,0],
      [0,0,6,0,5,0,0,2,0],
      [0,0,0,8,0,2,0,0,0],
      [0,7,0,0,0,9,0,0,0],
      [0,0,0,0,3,0,0,5,6],
      [0,4,0,0,0,8,9,0,0],
      [0,0,0,0,0,0,0,0,1]
    ],
    // Puzzle 14 (21 clues)
    [
      [0,0,9,0,0,0,0,0,0],
      [0,8,0,1,0,0,0,0,2],
      [5,0,0,0,7,0,0,0,0],
      [0,0,0,0,6,0,0,5,0],
      [0,0,0,4,0,3,0,0,8],
      [0,3,0,0,0,8,0,0,0],
      [9,0,0,0,3,0,0,6,0],
      [6,0,0,0,0,0,9,7,0],
      [0,1,0,0,0,0,0,0,4]
    ],
    // Puzzle 15 (21 clues)
    [
      [4,0,0,0,0,0,0,0,0],
      [0,0,5,0,0,7,0,6,0],
      [0,8,0,1,0,0,0,0,0],
      [0,0,0,0,2,9,0,5,0],
      [0,0,2,0,5,0,0,0,0],
      [0,0,0,3,0,0,8,0,0],
      [0,4,0,2,0,0,3,0,0],
      [0,3,0,0,0,0,1,0,4],
      [0,0,7,0,0,0,0,9,0]
    ],
    // Puzzle 16 (21 clues)
    [
      [0,4,0,0,0,0,0,0,0],
      [2,0,0,0,0,0,8,0,4],
      [0,0,1,0,0,7,0,6,0],
      [0,0,6,0,9,0,0,0,0],
      [5,0,0,8,0,0,0,0,7],
      [0,0,0,0,7,1,0,0,0],
      [0,0,3,0,1,0,0,9,0],
      [0,0,0,0,0,0,4,0,0],
      [0,0,0,2,0,0,5,0,8]
    ],
    // Puzzle 17 (21 clues)
    [
      [0,1,0,9,0,0,2,0,0],
      [6,0,0,0,8,0,0,0,0],
      [0,0,4,0,0,0,0,0,0],
      [0,0,0,0,7,0,0,0,6],
      [0,0,0,3,0,5,1,0,0],
      [0,5,0,0,0,1,0,0,0],
      [4,0,0,0,5,0,0,0,7],
      [7,0,0,0,0,0,0,4,8],
      [0,9,0,0,0,0,3,0,0]
    ],
    // Puzzle 18 (21 clues)
    [
      [7,0,0,0,0,5,0,0,0],
      [0,0,2,0,0,0,0,0,0],
      [0,3,0,0,6,0,0,0,4],
      [0,8,0,3,0,0,0,0,0],
      [0,0,0,0,0,1,0,7,0],
      [0,0,0,8,9,0,0,0,3],
      [1,0,0,0,0,0,2,5,0],
      [0,6,0,0,0,0,0,0,9],
      [2,0,0,0,0,8,0,1,0]
    ],
    // Puzzle 19 (21 clues)
    [
      [0,1,0,0,0,0,0,0,0],
      [4,0,0,0,0,0,9,0,1],
      [0,0,6,0,0,7,0,3,0],
      [8,0,0,9,0,0,0,0,7],
      [0,0,0,0,7,6,0,0,0],
      [0,0,3,0,2,0,0,0,0],
      [0,0,0,0,0,0,1,0,0],
      [0,0,0,4,0,0,8,0,9],
      [0,0,5,0,6,0,0,2,0]
    ],
    // Puzzle 20 (21 clues)
    [
      [0,0,9,2,0,0,0,0,0],
      [0,6,0,0,0,0,0,0,0],
      [8,0,0,0,0,3,4,0,0],
      [5,0,0,0,8,0,0,0,0],
      [0,0,0,7,0,0,0,0,9],
      [0,0,0,0,5,1,8,0,0],
      [0,0,7,0,0,0,0,6,2],
      [3,0,0,0,0,0,1,0,0],
      [0,0,6,5,0,0,0,0,7]
    ]
]
        };

        // --- DOM Elements ---
        const gridElement = document.getElementById('sudoku-grid');
        const messageArea = document.getElementById('message-area');
        const newGameBtn = document.getElementById('new-game-btn');
        const saveGameBtn = document.getElementById('save-game-btn');
        const loadGameBtn = document.getElementById('load-game-btn');
        const bestTimesBtn = document.getElementById('best-times-btn');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const validateBtn = document.getElementById('validate-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const radialMenuElement = document.getElementById('radial-menu');
        const headingElement = document.getElementById('main-headline');
        const confettiContainer = document.getElementById('confetti-container');
        const difficultySelect = document.getElementById('difficulty');
        const timerElement = document.getElementById('timer');
        const pauseBtn = document.getElementById('pause-btn');
        const gridWrapper = document.querySelector('.grid-wrapper');
        const radialMenuOverlay = document.getElementById('radial-menu-overlay');
        // Modals
        const saveTimeModal = document.getElementById('save-time-modal');
        const bestTimesModal = document.getElementById('best-times-modal');
        const loadGameModal = document.getElementById('load-game-modal');
        const finalTimeSpan = document.getElementById('final-time');
        const saveTimeYesBtn = document.getElementById('save-time-yes');
        const saveTimeNoBtn = document.getElementById('save-time-no');
        const bestTimesContent = document.getElementById('best-times-content');
        const closeBestTimesBtn = document.getElementById('close-best-times');
        const savedGamesList = document.getElementById('saved-games-list');
        const closeLoadGameBtn = document.getElementById('close-load-game');

        // --- Game State ---
        const gameState = {
            initialBoard: [], currentBoard: [], notesBoard: [], moveHistory: [],
            settings: { isInstantValidationEnabled: true },
            timer: { interval: null, seconds: 0 },
            isPaused: false, isRadialMenuOpen: false, radialTargetCell: null,
            pressTimer: null, isLongPress: false, lastMenuCloseTime: 0,
            messageTimer: null, isPlayerAction: true,
            lastPuzzleIndices: { easy: -1, medium: -1, hard: -1, expert: -1 },
            currentDifficulty: 'medium'
        };
        
        let sudokuWorker = null;
        
        const difficultyTranslations = {
            easy: 'Leicht',
            medium: 'Mittel',
            hard: 'Schwer',
            expert: 'Experte'
        };

        // --- Helper Functions ---
        const formatTime = (seconds) => {
            const min = Math.floor(seconds / 60).toString().padStart(2, '0');
            const sec = (seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        };
        
        const setsAreEqual = (setA, setB) => {
            if (setA.size !== setB.size) return false;
            for (const item of setA) if (!setB.has(item)) return false;
            return true;
        };
        
        // --- Save & Load Game ---
        function getSavedGames() {
            return JSON.parse(localStorage.getItem('sudokuSaveSlots') || '[]');
        }
        
        function saveGames(slots) {
            localStorage.setItem('sudokuSaveSlots', JSON.stringify(slots));
            updateLoadButtonState();
        }
        
        function saveCurrentGame() {
            if (!gameState.initialBoard || gameState.initialBoard.length === 0) {
                displayMessage("Kein aktives Spiel zum Speichern.", false);
                return;
            }
            
            const savedGames = getSavedGames();
            const newSave = {
                id: Date.now(),
                savedAt: new Date().toLocaleString('de-DE'),
                difficulty: gameState.currentDifficulty,
                seconds: gameState.timer.seconds,
                initialBoard: gameState.initialBoard,
                currentBoard: gameState.currentBoard,
                notesBoard: gameState.notesBoard.map(row => row.map(cellNotes => Array.from(cellNotes))),
            };

            savedGames.unshift(newSave); // Add to the beginning of the list
            saveGames(savedGames);
            displayMessage("Spiel gespeichert!", true);
        }

        function loadGame(saveId) {
            const savedGames = getSavedGames();
            const gameToLoad = savedGames.find(g => g.id === saveId);

            if (!gameToLoad) {
                displayMessage("Spielstand nicht gefunden.", false);
                return;
            }
            
            stopTimer();
            if (gameState.isPaused) togglePause();

            gameState.initialBoard = gameToLoad.initialBoard;
            gameState.currentBoard = gameToLoad.currentBoard;
            gameState.notesBoard = gameToLoad.notesBoard.map(row => row.map(cellNotesArray => new Set(cellNotesArray)));
            gameState.timer.seconds = gameToLoad.seconds;
            gameState.currentDifficulty = gameToLoad.difficulty;
            difficultySelect.value = gameToLoad.difficulty;
            gameState.moveHistory = [];
            
            saveGameBtn.disabled = false;
            
            renderBoard();
            updateUndoButtonState();
            resumeTimer();
            loadGameModal.classList.remove('visible');
            displayMessage("Spielstand geladen!", true);
        }
        
        function deleteSave(saveId) {
            let savedGames = getSavedGames();
            savedGames = savedGames.filter(g => g.id !== saveId);
            saveGames(savedGames);
            populateLoadGameModal(); // Refresh the list
        }
        
        function updateLoadButtonState() {
            const savedGames = getSavedGames();
            loadGameBtn.disabled = savedGames.length === 0;
        }


        // --- Best Times Logic (localStorage) ---
        const getBestTimes = () => {
            const times = localStorage.getItem('sudokuBestTimes');
            return times ? JSON.parse(times) : { easy: [], medium: [], hard: [], expert: [] };
        };

        const saveBestTimes = (times) => {
            localStorage.setItem('sudokuBestTimes', JSON.stringify(times));
        };

        const addBestTime = (difficulty, timeInSeconds, board) => {
            const bestTimes = getBestTimes();
            const timesForDifficulty = bestTimes[difficulty];
            const newEntry = { time: timeInSeconds, board: board };
            timesForDifficulty.push(newEntry);
            timesForDifficulty.sort((a, b) => a.time - b.time);
            bestTimes[difficulty] = timesForDifficulty.slice(0, MAX_BEST_TIMES);
            saveBestTimes(bestTimes);
        };


        // --- Timer ---
        function startTimer() {
            stopTimer();
            gameState.timer.seconds = 0;
            pauseBtn.disabled = false;
            updateTimerDisplay();
            startTimerInterval();
        }
        function stopTimer() { clearInterval(gameState.timer.interval); gameState.timer.interval = null; }
        function resumeTimer() {
            if (gameState.timer.interval || gameState.isPaused) return;
            startTimerInterval();
        }
        function startTimerInterval() {
             gameState.timer.interval = setInterval(() => {
                gameState.timer.seconds++;
                updateTimerDisplay();
            }, 1000);
        }
        function updateTimerDisplay() { timerElement.textContent = formatTime(gameState.timer.seconds); }

        function togglePause() {
            if (gridElement.classList.contains('grid-win')) return;
            gameState.isPaused = !gameState.isPaused;
            gridWrapper.classList.toggle('paused', gameState.isPaused);
            if (gameState.isPaused) { stopTimer(); pauseBtn.innerHTML = '&#9658;'; } 
            else { resumeTimer(); pauseBtn.innerHTML = '&#10074;&#10074;'; }
        }

        // --- Game Logic ---
        function startNewGame() {
            saveGameBtn.disabled = false;
            displayMessage('');
            if (gameState.isPaused) { gameState.isPaused = false; gridWrapper.classList.remove('paused'); pauseBtn.innerHTML = '&#10074;&#10074;'; }
            
            newGameBtn.disabled = true;
            difficultySelect.disabled = true;
            gameState.currentDifficulty = difficultySelect.value;

            if (gameState.currentDifficulty === 'expert') {
                const puzzlePool = PUZZLES.expert;
                let newIndex;
                do { newIndex = Math.floor(Math.random() * puzzlePool.length); } 
                while (puzzlePool.length > 1 && newIndex === gameState.lastPuzzleIndices.expert);
                gameState.lastPuzzleIndices.expert = newIndex;
                initializeBoardWithPuzzle(puzzlePool[newIndex]);
            } else {
                displayMessage('Neues Puzzle wird generiert...', false, 0);
                const clues = DIFFICULTY_LEVELS[gameState.currentDifficulty];
                if (sudokuWorker) sudokuWorker.terminate();
                const workerScript = document.getElementById('sudoku-worker').textContent;
                const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
                const objectURL = URL.createObjectURL(workerBlob);
                sudokuWorker = new Worker(objectURL);
                sudokuWorker.addEventListener('message', (e) => {
                    handleWorkerResponse(e);
                    URL.revokeObjectURL(objectURL);
                }, { once: true });
                sudokuWorker.postMessage({ clues });
            }
        }
        
        function initializeBoardWithPuzzle(newPuzzle) {
            gameState.initialBoard = newPuzzle.map(row => [...row]);
            initializeBoardsFrom(gameState.initialBoard);
            renderBoard();
            updateUndoButtonState();
            startTimer();
            newGameBtn.disabled = false;
            difficultySelect.disabled = false;
        }

        function handleWorkerResponse(e) {
            if (sudokuWorker) { sudokuWorker.terminate(); sudokuWorker = null; }
            initializeBoardWithPuzzle(e.data);
            displayMessage('');
        }

        function resetGame() {
            if (gameState.isPaused) { gameState.isPaused = false; gridWrapper.classList.remove('paused'); pauseBtn.innerHTML = '&#10074;&#10074;'; }
            initializeBoardsFrom(gameState.initialBoard);
            renderBoard();
            updateUndoButtonState();
            startTimer();
        }

        function initializeBoardsFrom(initial) {
            gameState.currentBoard = initial.map(row => [...row]);
            gameState.notesBoard = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => new Set()));
            gameState.moveHistory = [];
        }

        function placeNumber(row, col, number, isNote) {
            const prevAnswer = gameState.currentBoard[row][col];
            const prevNotes = new Set(gameState.notesBoard[row][col]);

            if (isNote) {
                if (prevAnswer !== 0) return;
                if (gameState.notesBoard[row][col].has(number)) gameState.notesBoard[row][col].delete(number);
                else gameState.notesBoard[row][col].add(number);
            } else {
                gameState.notesBoard[row][col].clear();
                gameState.currentBoard[row][col] = (prevAnswer === number) ? 0 : number;
            }
            
            if (!setsAreEqual(new Set(gameState.notesBoard[row][col]), prevNotes) || prevAnswer !== gameState.currentBoard[row][col]) {
                 gameState.moveHistory.push({ row, col, prevAnswer, prevNotes });
            }
           
            updateUndoButtonState();
            renderCell(row, col);
            if (gameState.settings.isInstantValidationEnabled) validateBoard();
            checkWinCondition();
        }
        
        function undoLastMove() {
            if (gameState.moveHistory.length === 0) return;
            const lastMove = gameState.moveHistory.pop();
            gameState.currentBoard[lastMove.row][lastMove.col] = lastMove.prevAnswer;
            gameState.notesBoard[lastMove.row][lastMove.col] = lastMove.prevNotes;
            updateUndoButtonState();
            renderCell(lastMove.row, lastMove.col);
            if (gameState.settings.isInstantValidationEnabled) validateBoard();
        }
        
        // --- Validation & Win ---
        function validateBoard() {
            let isValid = true;
            const cells = gridElement.querySelectorAll('.sudoku-cell');
            cells.forEach(cell => cell.querySelector('.answer-number').classList.remove('error'));
            const checkUnit = (unit, type, index, colIndex = null) => {
                const nums = unit.filter(num => num !== 0);
                if (new Set(nums).size !== nums.length) {
                    isValid = false;
                    markUnitInvalid(cells, type, index, colIndex);
                }
            };
            for (let i = 0; i < GRID_SIZE; i++) {
                checkUnit(gameState.currentBoard[i], 'row', i);
                checkUnit(gameState.currentBoard.map(row => row[i]), 'col', i);
            }
            for (let i = 0; i < GRID_SIZE; i += 3) {
                for (let j = 0; j < GRID_SIZE; j += 3) {
                    const box = [];
                    for (let row = i; row < i + 3; row++) for (let col = j; col < j + 3; col++) box.push(gameState.currentBoard[row][col]);
                    checkUnit(box, 'box', i, j);
                }
            }
            return isValid;
        }

        function markUnitInvalid(cells, type, index, colIndex = null) {
            for (let i = 0; i < GRID_SIZE; i++) {
                let cell;
                if (type === 'row') cell = cells[index * GRID_SIZE + i];
                else if (type === 'col') cell = cells[i * GRID_SIZE + index];
                else if (type === 'box') {
                    const row = index + Math.floor(i / 3);
                    const col = colIndex + (i % 3);
                    cell = cells[row * GRID_SIZE + col];
                }
                if (cell) cell.querySelector('.answer-number').classList.add('error');
            }
        }
        
        function checkWinCondition() {
            if (gameState.currentBoard.flat().includes(0)) return;
            if (validateBoard()) {
                stopTimer();
                saveGameBtn.disabled = true;
                pauseBtn.disabled = true;
                showSaveTimeModal();
            }
        }
        
        // --- Rendering ---
        function createGrid() {
            gridElement.innerHTML = '';
            for (let i = 0; i < NUM_CELLS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('sudoku-cell');
                cell.dataset.row = Math.floor(i / GRID_SIZE);
                cell.dataset.col = i % GRID_SIZE;
                cell.innerHTML = `<div class="notes-grid">${[1,2,3,4,5,6,7,8,9].map(n => `<div class="note-number" data-note="${n}">${n}</div>`).join('')}</div><div class="answer-number"></div>`;
                gridElement.appendChild(cell);
            }
        }

        function renderBoard() {
            for (let row = 0; row < GRID_SIZE; row++) for (let col = 0; col < GRID_SIZE; col++) renderCell(row, col);
            if (gameState.settings.isInstantValidationEnabled) validateBoard();
        }
        
        function renderCell(row, col) {
            const cell = gridElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
            if (!cell) return;
            const answerNumberEl = cell.querySelector('.answer-number');
            const notesGridEl = cell.querySelector('.notes-grid');
            const initialValue = gameState.initialBoard[row][col];
            const currentValue = gameState.currentBoard[row][col];
            cell.classList.toggle('initial', initialValue !== 0);
            if (currentValue !== 0) {
                answerNumberEl.textContent = currentValue;
                notesGridEl.style.display = 'none';
            } else {
                answerNumberEl.textContent = '';
                notesGridEl.style.display = 'grid';
                notesGridEl.querySelectorAll('.note-number').forEach(noteEl => {
                    noteEl.classList.toggle('visible', gameState.notesBoard[row][col].has(parseInt(noteEl.dataset.note, 10)));
                });
            }
        }

        // --- UI & Event Handlers ---
        function setupEventListeners() {
            newGameBtn.addEventListener('click', startNewGame);
            saveGameBtn.addEventListener('click', saveCurrentGame);
            loadGameBtn.addEventListener('click', showLoadGameModal);
            resetBtn.addEventListener('click', resetGame);
            undoBtn.addEventListener('click', undoLastMove);
            validateBtn.addEventListener('click', () => {
                if (validateBoard()) displayMessage('Das Board ist korrekt (bis jetzt)!', true);
                else displayMessage('Es wurden Fehler gefunden.', false);
            });
            settingsBtn.addEventListener('click', toggleInstantValidation);
            themeToggleBtn.addEventListener('click', toggleTheme);
            pauseBtn.addEventListener('click', togglePause);
            gridElement.addEventListener('click', handleCellClick);
            radialMenuElement.addEventListener('pointerdown', handleMenuPointerDown);
            radialMenuElement.addEventListener('pointerup', handleMenuUp);
            radialMenuOverlay.addEventListener('click', hideRadialMenu);
            
            // Modals
            bestTimesBtn.addEventListener('click', showBestTimesModal);
            closeBestTimesBtn.addEventListener('click', () => bestTimesModal.classList.remove('visible'));
            closeLoadGameBtn.addEventListener('click', () => loadGameModal.classList.remove('visible'));
            
            saveTimeYesBtn.addEventListener('click', () => {
                addBestTime(gameState.currentDifficulty, gameState.timer.seconds, gameState.initialBoard);
                hideSaveTimeModalAndWin();
            });
            saveTimeNoBtn.addEventListener('click', hideSaveTimeModalAndWin);
        }

        // --- Theme Toggle ---
        function applyInitialTheme() {
            const savedTheme = localStorage.getItem('sudokuTheme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.body.classList.add('dark-mode');
                themeToggleBtn.innerHTML = '‚òÄÔ∏è';
            } else {
                document.body.classList.remove('dark-mode');
                themeToggleBtn.innerHTML = 'üåô';
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            if (document.body.classList.contains('dark-mode')) {
                localStorage.setItem('sudokuTheme', 'dark');
                themeToggleBtn.innerHTML = '‚òÄÔ∏è';
            } else {
                localStorage.setItem('sudokuTheme', 'light');
                themeToggleBtn.innerHTML = 'üåô';
            }
        }
        
        // --- Modals ---
        function showSaveTimeModal() {
            finalTimeSpan.textContent = formatTime(gameState.timer.seconds);
            saveTimeModal.classList.add('visible');
        }

        function hideSaveTimeModalAndWin() {
            saveTimeModal.classList.remove('visible');
            displayMessage(`Gl√ºckwunsch!`, true);
            triggerWinAnimation();
        }
        
        function populateLoadGameModal() {
            const savedGames = getSavedGames();
            savedGamesList.innerHTML = ''; // Clear existing list
            
            if (savedGames.length === 0) {
                savedGamesList.innerHTML = '<p>Keine Spielst√§nde vorhanden.</p>';
                return;
            }

            savedGames.forEach(game => {
                const li = document.createElement('li');
                li.classList.add('saved-game-item');
                
                li.innerHTML = `
                    <div class="saved-game-info">
                        <strong>${game.savedAt}</strong>
                        <span>${difficultyTranslations[game.difficulty]} - ${formatTime(game.seconds)}</span>
                    </div>
                    <div class="saved-game-actions">
                        <button class="btn-load-save" data-id="${game.id}">Laden</button>
                        <button class="btn-delete-save" data-id="${game.id}">L√∂schen</button>
                    </div>
                `;
                savedGamesList.appendChild(li);
            });

            // Add event listeners after creating the buttons
            savedGamesList.querySelectorAll('.btn-load-save').forEach(btn => {
                btn.addEventListener('click', (e) => loadGame(Number(e.target.dataset.id)));
            });
            savedGamesList.querySelectorAll('.btn-delete-save').forEach(btn => {
                btn.addEventListener('click', (e) => deleteSave(Number(e.target.dataset.id)));
            });
        }

        function showLoadGameModal() {
            populateLoadGameModal();
            loadGameModal.classList.add('visible');
        }

        function showBestTimesModal() {
            const bestTimes = getBestTimes();
            bestTimesContent.innerHTML = '';
            ['easy', 'medium', 'hard', 'expert'].forEach(diff => {
                const times = bestTimes[diff];
                const section = document.createElement('div');
                section.innerHTML = `<h3>${difficultyTranslations[diff]}</h3>`;
                if (times.length > 0) {
                    const ol = document.createElement('ol');
                    times.forEach(entry => {
                        const li = document.createElement('li');
                        const timeSpan = document.createElement('span');
                        timeSpan.textContent = formatTime(entry.time);
                        const playBtn = document.createElement('button');
                        playBtn.textContent = 'Spielen';
                        playBtn.classList.add('btn-play-again');
                        playBtn.addEventListener('click', () => {
                            bestTimesModal.classList.remove('visible');
                            difficultySelect.value = diff;
                            gameState.currentDifficulty = diff;
                            initializeBoardWithPuzzle(entry.board);
                        });
                        li.appendChild(timeSpan);
                        li.appendChild(playBtn);
                        ol.appendChild(li);
                    });
                    section.appendChild(ol);
                } else {
                    section.innerHTML += `<p class="no-times">Noch keine Zeiten gespeichert.</p>`;
                }
                bestTimesContent.appendChild(section);
            });
            bestTimesModal.classList.add('visible');
        }

        // --- Radial Menu ---
        function createRadialMenuItems() {
            radialMenuElement.innerHTML = '';
            const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
            const radius = RADIAL_MENU_DIAMETER / 2 - 25;

            items.forEach(num => {
                const item = document.createElement('div');
                item.classList.add('radial-item');
                item.dataset.number = num;

                if (num === 0) {
                    item.innerHTML = '&#x232B;';
                    item.style.left = '50%';
                    item.style.top = '50%';
                } else {
                    item.textContent = num;
                    const angle = (num - 1) * 40 - 90; 
                    const x = Math.cos(angle * Math.PI / 180) * radius + (RADIAL_MENU_DIAMETER / 2);
                    const y = Math.sin(angle * Math.PI / 180) * radius + (RADIAL_MENU_DIAMETER / 2);
                    item.style.left = `${x}px`;
                    item.style.top = `${y}px`;
                }
                item.style.transform = 'translate(-50%, -50%)'; 
                radialMenuElement.appendChild(item);
            });
        }

        function handleCellClick(e) {
            if (gameState.isPaused) return;
            const cell = e.target.closest('.sudoku-cell');
            if (!cell || cell.classList.contains('initial')) return;

            if (gameState.isRadialMenuOpen && cell === gameState.radialTargetCell) {
                hideRadialMenu();
                return;
            }
            showRadialMenu(e.clientX, e.clientY, cell);
        }

        function handleMenuPointerDown(e) {
            const targetItem = e.target.closest('.radial-item');
            if (!targetItem) return;

            e.stopPropagation();
            gameState.isLongPress = false;
            targetItem.classList.remove('longpress-active');

            gameState.pressTimer = setTimeout(() => {
                gameState.isLongPress = true;
                targetItem.classList.add('longpress-active');
            }, LONG_PRESS_DURATION);
        }

        function handleMenuUp(e) {
            clearTimeout(gameState.pressTimer);
            const targetItem = e.target.closest('.radial-item');
            if (!targetItem) return;

            e.stopPropagation();

            if (gameState.radialTargetCell) {
                 const number = parseInt(targetItem.dataset.number, 10);
                 const row = parseInt(gameState.radialTargetCell.dataset.row, 10);
                 const col = parseInt(gameState.radialTargetCell.dataset.col, 10);
                 placeNumber(row, col, number, gameState.isLongPress);
            }
            setTimeout(hideRadialMenu, 0);
            gameState.isLongPress = false;
        }

        function showRadialMenu(x, y, cell) {
            if (Date.now() - gameState.lastMenuCloseTime < REOPEN_DELAY) return;

            const radius = RADIAL_MENU_DIAMETER / 2;
            const padding = 10; // A little space from the edge

            // Adjust X coordinate
            if (x + radius > window.innerWidth) {
                x = window.innerWidth - radius - padding;
            }
            if (x - radius < 0) {
                x = radius + padding;
            }

            // Adjust Y coordinate
            if (y + radius > window.innerHeight) {
                y = window.innerHeight - radius - padding;
            }
            if (y - radius < 0) {
                y = radius + padding;
            }
            
            radialMenuOverlay.style.display = 'block';
            cell.classList.add('selected');
            radialMenuElement.style.left = `${x}px`;
            radialMenuElement.style.top = `${y}px`;
            radialMenuElement.classList.add('visible');
            gameState.radialTargetCell = cell;
            gameState.isRadialMenuOpen = true;
        }

        function hideRadialMenu() {
            if (!gameState.isRadialMenuOpen) return;
            radialMenuOverlay.style.display = 'none';
            gridElement.querySelectorAll('.selected').forEach(c => c.classList.remove('selected'));
            radialMenuElement.querySelectorAll('.radial-item').forEach(item => item.classList.remove('longpress-active'));
            radialMenuElement.classList.remove('visible');
            gameState.isRadialMenuOpen = false;
            gameState.lastMenuCloseTime = Date.now();
            gameState.radialTargetCell = null;
        }
        
        function updateUndoButtonState() { undoBtn.disabled = gameState.moveHistory.length === 0; }

        function toggleInstantValidation() {
            gameState.settings.isInstantValidationEnabled = !gameState.settings.isInstantValidationEnabled;
            updateSettingsButtonVisual();
            if (gameState.settings.isInstantValidationEnabled) validateBoard();
            else gridElement.querySelectorAll('.error').forEach(el => el.classList.remove('error'));
        }
        function updateSettingsButtonVisual() { settingsBtn.classList.toggle('active', gameState.settings.isInstantValidationEnabled); }

        function displayMessage(msg, isSuccess = false, duration = 3000) {
            clearTimeout(gameState.messageTimer);
            messageArea.textContent = msg;
            messageArea.className = 'message-area';
            if (msg) {
                if (isSuccess) messageArea.classList.add('success');
                else if (msg !== 'Neues Puzzle wird generiert...') messageArea.classList.add('failure');
            }
            if (duration > 0) gameState.messageTimer = setTimeout(() => messageArea.classList.add('hidden'), duration);
        }

        function triggerWinAnimation() {
            headingElement.classList.add('headline-win');
            gridElement.classList.add('grid-win');
            let confettiInterval = setInterval(() => { for (let i = 0; i < 10; i++) createConfettiPiece() }, 200);
            setTimeout(() => { clearInterval(confettiInterval); headingElement.classList.remove('headline-win'); gridElement.classList.remove('grid-win'); }, 5000);
        }
        function createConfettiPiece() {
             const piece = document.createElement('div');
            piece.classList.add('confetti-piece');
            piece.style.left = `${Math.random() * 100}vw`;
            piece.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
            piece.style.transform = `rotate(${Math.random() * 360}deg)`;
            piece.style.setProperty('--drift', `${(Math.random() - 0.5) * 200}px`);
            confettiContainer.appendChild(piece);
            setTimeout(() => piece.remove(), 4000);
        }

        // --- Init ---
        function init() {
            createGrid();
            createRadialMenuItems();
            setupEventListeners();
            applyInitialTheme();
            updateSettingsButtonVisual();
            updateLoadButtonState();
            startNewGame();
        }
        init();
    });
    </script>
</body>
</html>


